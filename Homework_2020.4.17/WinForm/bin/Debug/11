<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="never" />
    <meta property="og:description" content="目的 在平常的前端开发中，一般需要处理数据（数组和对象居多），特别是复杂功能的页面，通常是一到两个对象数组（有时数组里面还有数组）。大多数前端开发的难点就是这里，耗时大。以前我在工作中，遇到的支付方式" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>js使用经验--遍历 - stephenWu5 - 博客园</title>
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=BKtyzabbeYJEVOaELkxmRjHbp7LT-v37GzrU5S24bJk" />
    <link id="MainCss" rel="stylesheet" href="/skins/codinglife/bundle-codinglife.min.css?v=hlpQ1CJDwwJXDxv2HNauUmW3NjyWzoMaw1uER19SLT0" />
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/codinglife/bundle-codinglife-mobile.min.css?v=XjHfryC9ctsatIZz1dHn7TsRIqmwz9c3aj_6SCfHSDM" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/StephenWu5/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/StephenWu5/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/StephenWu5/wlwmanifest.xml" />
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=VSP5rTXbJNpNidklGdgoLgwCGyUPITrcsmlgoaMKz3w"></script>
    <script>
        var currentBlogId = 470246;
        var currentBlogApp = 'StephenWu5';
        var cb_enable_mathjax = false;
        var isLogined = false;
        var skinName = 'CodingLife';
    </script>
    
    
    
</head>
<body>
    <a name="top"></a>
    
    
<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/StephenWu5/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/StephenWu5/">StephenWu5</a>
</h1>
<h2>
微信公众号：豆腐爱瑜伽
</h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/StephenWu5/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/stephenWu5">
联系</a></li>
<li>
<a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/StephenWu5/rss/">
订阅</a>
<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			
			<span id="stats_post_count">随笔 - 
9&nbsp; </span>
<span id="stats_article_count">文章 - 
0&nbsp; </span>
<span id="stats-comment_count">评论 - 
10</span>

			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class = "postTitle">
                
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/StephenWu5/p/12730384.html">js使用经验--遍历</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
    <h2 id="目的">目的</h2>
<p>在平常的前端开发中，一般需要处理数据（数组和对象居多），特别是复杂功能的页面，通常是一到两个对象数组（有时数组里面还有数组）。大多数前端开发的难点就是这里，耗时大。以前我在工作中，遇到的支付方式功能，排课日历，场地预约，公园大屏幕运动排行和弹幕，后台系统的权限模块等等，这些功能难度大费脑耗时间多。其他那些功能很简单的，无脑复制粘贴运行就完成了。如果我可以总结一下，找出一些高效的处理数组和对象的方法，以后工作中就对号入座的使用，这肯定可以提高我的工作效率，到时候我可以多出时间来给测试或者学习新知识或者摸鱼休息。这总比每天瞎用<code>js</code>工具类，碌碌无为的写代码强。</p>
<p>做一件事有很多种方法，最快捷的就那一两个，把它们找出来，事半功倍。正所谓磨刀不误砍柴工。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8195910-76873caf090eaa65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="空虚"></p>
<h2 id="数组的遍历">数组的遍历</h2>
<h4 id="一、forof通用">一、for...of(通用)</h4>
<p>最好用的迭代（循环）语句</p>
<p>说到循环，javascript的循环语句那么多，我该如何选择？其实就是问下自己，自己需要什么？我眼睛一闭，我要可以用在很多地方（对象），写法简单，这样维护性高；我还要支持<code>continue，break，throw，return</code>打断循环或者跳到下一个循环（某一次迭代不执行循环体代码块），我还要<code>index</code>，<code>index</code>等于某个值时做一些逻辑判断。</p>
<p><code>for...of</code>，它可以用于可迭代对象。<code>Array，Map，Set，String，TypeArray，arguments</code>等等。就是说可用的地方很广，哪里都能用。迭代是啥意思，就是说按顺序访问列表中的每一项，就是小时候老师家访那样，学生的家走一遍。其实在项目中，一般都是遍历对象数组，这样的数据结构前端后台耳熟能祥。</p>
<p>这个东西性能不算好的，是es2015推出来的，写法特别简洁。运行效率中下，比<code>for，forEach</code>差，但是比<code>map</code>好。优点是占用内存最小。其实运行效率和占用内存是次要的，因为在项目中，处理的数据的长度不会很长，一般在10到30之间，影响不大，再说前端在大多数情况下不需要考虑性能（上一家公司技术大哥给我的经验）。写法简洁的话，在二层循环的情况代码的阅读性和维护性就较高。</p>
<p>处理逻辑时，一般需要（特别需要）使用<code>break，continue，return</code>来设计代码逻辑。不是所有的循环语句都支持<code>return ，break</code>。记得有一次我使用<code>forEach</code>语句的时候，循环体里面加了<code>break</code>，发现跳不出去。搞半天原来是不支持。现实又狠狠的打了我这种渣渣一耳光。改为<code>for</code>语句解决了。</p>
<p><code>index</code>它是不支持的，不是你要什么它就是支持什么。可以通过把数组等转化为<code>Map</code>对象。实现如下：</p>
<pre><code class="language-javascript">for(let [index,item] of new Map(targetArray.map((item,i) =&gt; [i,item]))){
    console.log(index, item)
} 
</code></pre>
<h4 id="二、reduce，reduceright（百变）">二、reduce，reduceRight（百变）</h4>
<p><code>reduce</code>循环（招式很多）</p>
<p>一开始我以为<code>reduce</code>只能求和，没什么用，查询大神写的博客，我才知道它很厉害。我开始要抄别人的东西了。没办法，技术不行。</p>
<p>数组求和，求乘积(其实求减，求除也是没有问题的啰)</p>
<pre><code class="language-javascript">var  arr = [1, 2, 3, 4];
var sum = arr.reduce((x,y)=&gt;x+y)
var mul = arr.reduce((x,y)=&gt;x*y)
console.log( sum ); //求和，10
console.log( mul ); //求乘积，24

//其实对象数组也可以求和，为所欲为啊
var  arr = [{num: 1}, {num: 2}];
var sum = arr.reduce((x,y)=&gt;x+y.num,0)
</code></pre>
<p>计算一个数组中元素成员的次数（利用了一个<code>reduce</code>的第二参数初始化为空对象，用这个对象来记录数组出现的次数。然后把这个对象给饼状图。不过一般后台会直接给前台这个对象，不需要前台计算。）</p>
<pre><code class="language-javascript">let names = ['Alice', 'Bob', 'Alice'];

let nameNum = names.reduce((pre,cur)=&gt;{
  if(cur in pre){
    pre[cur]++
  }else{
    pre[cur] = 1 
  }
  return pre
},{})
console.log(nameNum); //{Alice: 

//万一数组的每一项是对象，能不能搞啊 可以的，拓展一下就可以了。看
let names = [{name:'Alice'}, {name: 'Bob'}, {name: 'Alice'}];
let nameNum = names.reduce((pre,cur)=&gt;{
  if(cur.name &amp;&amp; cur.name in pre){
    pre[cur.name]++
  }else{
    pre[cur.name] = 1 
  }
  return pre
},{})
console.log(nameNum); //{Alice: 
</code></pre>
<p>数组去重，这个功能经常遇到，当数组出现重复，后台不好处理时，这时需要前端去重(利用了第二个参数初始化为空数组，)</p>
<pre><code class="language-javascript">let arr = [1,2,3,4,4,1]
let newArr = arr.reduce((pre,cur)=&gt;{
    if(!pre.includes(cur)){
      return pre.concat(cur)
    }else{
      return pre
    }
},[])
console.log(newArr);// [1, 2, 3, 4]
//对象数组去重和上面一样，拓展一下
let arr = [{num: 1},{num: 2},{num: 3},{num: 3}]
let temp = {};
let newArr = arr.reduce((pre,cur)=&gt;{
    if(!temp[cur.num]){
      temp[cur.num] = true;
      return pre.concat(cur)
    }else{
      return pre
    }
},[])
console.log(newArr);// [1, 2, 3, 4]

</code></pre>
<p>看了一下人家的博客，发现<code>reduce</code>还能快速实现<code>filter</code>的功能。为所欲为啊。实现如下。</p>
<pre><code>const data = [
  {name: 'a', age: 37, weight: 72, sex: 'male'},
];
// accu 为 accumulator，curr 为 currentValue
const result = data.reduce((accu, curr) =&gt; {
  // if 判断，相当于 filter
  if (curr.sex === 'female') {
    accu.push(curr);
  }
  return accu;
}, []);
console.log(result);
</code></pre>
<p>递归处理<code>tree</code>树形，这种需求在工作中没有遇到过，不知道以后会不会遇到。代码中的<code>callee</code>是个指针，指向当前执行的函数，就是函数它自己，一旦是用于递归处理。如果不这样写的哈，就需要定义个函数变量，在函数内部调用自己。函数定义在<code>reduce</code>的外面，代码的阅读性降低。<code>callee</code>就是提供快捷编码，提高代码的阅读性。</p>
<pre><code>var data = [{
            id: 1,
            name: &quot;办公管理&quot;,
            pid: 0,
            children: [{
                    id: 2,
                    name: &quot;请假申请&quot;,
                    pid: 1,
                    children: [
                        { id: 4, name: &quot;请假记录&quot;, pid: 2 },
                    ],
                },
                { id: 3, name: &quot;出差申请&quot;, pid: 1 },
            ]
        }
    ];
    const arr = data.reduce(function(pre,item){
        const callee = arguments.callee //将运行函数赋值给一个变量备用  
        pre.push(item)
        if(item.children &amp;&amp; item.children.length &gt; 0) item.children.reduce(callee,pre); //判断当前参数中是否存在children，有则递归处理
        return pre;
    },[]).map((item) =&gt; {
        //清空每一项item
        item.children = []
        return item
    })
    console.log(arr)
</code></pre>
<p>他还有个兄弟，叫<code>reduceRight</code>，只是循序不一样，一个是顺序，一个是倒叙而已。功能几乎一模一样为什么还要搞两个？程序员有时真的是无聊到极点。我会不会去学<code>reduceRight</code>?我不学，机智躲开。</p>
<p>有个大佬写了<code>reduce</code>的高级用法</p>
<p><a href="https://developer.51cto.com/art/202002/610535.htm">https://developer.51cto.com/art/202002/610535.htm</a></p>
<h4 id="三、some，every，filters，map-（私人定制）">三、some，every，filters，map （私人定制）</h4>
<p>要想快速实现某些功能，就要使用功能专一的。</p>
<p><code>some</code> 和 <code>every</code></p>
<p>他们是两兄弟，需要的参数可以是函数，返回值是true和false。前者有一个条件满足，函数返回值是<code>true</code>，就停止遍历。后者是所有条件满足，函数返回值是<code>true</code>，就停止遍历。</p>
<p>几乎没有用过，不知道使用场景。应该是算是否全勤，一个班的同学是否全部及格。还有全选效果的实现吧。</p>
<p><code>filter</code>(推荐)</p>
<p>官方的解释是找到所有符合条件的元素然后放到一个数组中 如果没有符合条件的那么返回空数组。物如其名，就是一个过滤器，拿到符合条件的数据项拼成新的数据。</p>
<p>使用场景很多，渲染页面的时候，需要拼接符合条件的数组和给后台数据的时候，给后台符合条件的数据。<strong>按某个属性分组</strong>。上一家公司的时候，写跑步比赛页面，页面需要显示跑步中，没开始，跑完等状态。此时如果使用<code>filter</code>，就快速得到需要的数组。</p>
<p><code>map</code></p>
<p>就是需要对一个数组的每一项做相同的操作处理时。使用<code>map</code>就会很快。<code>map</code>不会改变原来的数组这个定律适用于数组成员是值类型。如果是引用类型，这个不适用。</p>
<p>那么如何快速的选择合适的遍历数组的方法呢？根据开发工作中的需求，首先审查功能专一私人定制的<code>some，every，filters，map</code>，再到<code>reduce</code>。这时候千万不能轻易跳到<code>for...of</code>。在<code>reduce</code>这一层尽情耍大刀。如果实在不行了，就<code>for...of</code>呗。</p>
<h2 id="对象的遍历">对象的遍历</h2>
<p>在工作中除了处理数据，处理对象也是常见。</p>
<h4 id="一、forin">一、for...in</h4>
<p>这个是一般用法。使用很简单。</p>
<h4 id="二、keys，getownpropertynames，ownkeys-推荐">二、keys，getOwnPropertyNames，ownKeys (推荐)</h4>
<p>他们的使用一模一样，都很简单。 <code>keys</code>遍历自身的可枚举属性。 <code>getOwnPropertyNames</code>遍历自身的所有属性。 <code>ownKeys</code>遍历自身属性（包括<code>Symbol</code>）。</p>
<p>其实不乱的，需要知道属性有可枚举与不可枚举，是否是Symbol。根据实质情况去选择就行了。再说工作中大多数的对象的属性都是可枚举的，用 <code>keys</code>可以解决大多数需求。</p>
<p>为什么要推荐使用 <code>keys</code>等。可以试想一下，把对象转化得到数组之后，不就是可以使用上面数组循环的那些方法处理各种逻辑？什么<code>reduce,filter,map,some，every</code>对吧，特别那个<code>reduce</code>就和周杰伦双截棍那样，怎么耍都可以。又快又简洁。</p>
<pre><code class="language-javascript">var obj = {'0': 1, '1': b}
Object.keys(obj).forEach((key) =&gt;{
    console.log(key,obj[key])
})
</code></pre>
<p>在以前公司的项目中，我发现可以这样写接口，每次添加接口只需要在<code>urlMap</code>对象里面添加键值对：（或者说写在其他<code>js</code>文件，把几个对象合并到<code>urlMap</code>）。</p>
<p>这样处理的好处是，阅读舒服，代码维护性高，减少不必要的代码冲突，节省时间。</p>
<pre><code class="language-javascript">const urlMap = {
    loginUserInfo: '/api/loginUserInfo', //---方法名/接口路径---
};
const services = {};
 
Object.keys(urlMap).forEach((methodName) = &gt; {
    services[methodName] = function (params, async = true, type = 'GET') {
        var data = [];
        var promise = $.ajax({
            url: urlMap[methodName],
            data: params ? params : {},
            async: async,
            dataType: &quot;json&quot;
        });
        if (async) {
            return promise;
        } else {
            promise.done(({
                code, obj
            }) = &gt; {
                (code === 0) &amp;&amp; (data = obj)
            });
            return data;
        }
    };
});
 
export default services;
</code></pre>
<p>说个题外话的，处理对象的时候，有时候需要做对象合并处理。对象合并可以用在哪些地方？就是页面分页组件，<code>echart</code>组件它们需要配置对象，这个对象有很多的键值对。可以抽一些共同的属性处理预设值写在组件内部，其它的就写在组件外部传进来，这时候就需要合并它俩。这种概念叫做配置 <code>config</code>。</p>
<p>简单的写法就是使用 <code>Object.assingObj</code>；这个方法就是把多个源目标复制到目标对象，不管这个目标对象有没有这个属性值。</p>
<p>也可以使用严格一些的方法，就是说，目标对象和源对象公共的属性值，才搞到目标对象上，不是的话不要过来，否则可能会搞坏内部的配置。缺点就是在组件写配置对象时，需要多写(有可能是很多行)属性名，总是比每次写在组件外面强（代码如下）。</p>
<pre><code class="language-javascript">function assignObj(vm, firstSource) {
    for(let [index,item] of new Map([...arguments].map((item,i) =&gt; [i,item]))){
        if(index === 0)  continue; //躲开vm

        let nextSource = [...arguments][index];
        if (nextSource &amp;&amp; typeof nextSource !== &quot;object&quot;) continue;
        Object.keys(vm).reduce((pre,cur) =&gt; {
            if(vm.hasOwnProperty(cur) &amp;&amp; nextSource.hasOwnProperty(cur))

                vm[cur] = nextSource[cur]
        },vm)
    } 
    return vm
}

var returnValue =  assignObj({name: 'name',age: 6,hairs: 8},{name: 'name',age: 6,clothes: 'lalala1'},{name: '周星驰'})
console.log(returnValue,'returnValue')
</code></pre>
<p>有人可能会提问？当对象里面的属性又是对象时，你这个方法不支持啊。难不倒我，我可以用<code>callee</code>来升级的。</p>
<pre><code class="language-javascript">function assignObj(vm, firstSource) {
    const callee = arguments.callee //将运行函数赋值给一个变量备用  
    for(let [index,item] of new Map([...arguments].map((item,i) =&gt; [i,item]))){
        if(index === 0)  continue; //躲开vm

        let nextSource = [...arguments][index];
        if (nextSource &amp;&amp; typeof nextSource !== &quot;object&quot;) continue;
        Object.keys(vm).reduce((pre,cur) =&gt; {
            if(Object.prototype.toString.call(vm[cur]) !== '[object Object]' &amp;&amp; vm.hasOwnProperty(cur) &amp;&amp; nextSource.hasOwnProperty(cur))

            vm[cur] = nextSource[cur]
            else if(Object.prototype.toString.call(vm[cur]) === '[object Object]' &amp;&amp; vm.hasOwnProperty(cur) &amp;&amp; nextSource.hasOwnProperty(cur))
            callee(vm[cur],nextSource[cur]);
            return vm;
        },vm)
    } 
    return vm
}
</code></pre>
<p>如果不想在<code>vue</code>内部组件中写太多的组件初始化配置值的话，可以采取一种宽松的方式：就是说在目标对象的基础上，把所有源对象的属性复制过来，共同属性的值直接覆盖。其实很简单的，遍历源目标，属性是非对象把值复制过来，属性是对象再次遍历。 把上面代码的那行<code>Object.keys</code>出现的<code>vm</code>改为<code>nextSource</code>就可以了。</p>
<p>再说个题外话吧，就是上个月啊，和一个后台搞图片的功能。图片的待上传列表是那后台返回来的数组。写的时候，需要搞隐射，发现不好搞：一个页面，拿到<code>SPECIAL_FATE_STORE_HEADER</code>字段给后台<code>specialFateStoreHeaderId</code>字段；另外一个地方同理：<code>specialFateStoreHeaderId-&gt;STORE_HEADER</code>。为什么这么麻烦？后台小子逻辑差，经验不足，没处理好。一开始我使用<code>switch case</code>。搞了不少行代码，维护性也不好，因为有两套，改其中一个，另外一个也得跟着改。这时候，上面的那些数组遍历和对象遍历的内容就可以用进来了。再一次证明会<code>js</code>真的可以为所欲为，呵呵。代码如下。</p>
<pre><code class="language-javascript">let valueMap = {
    SPECIAL_FATE_STORE_HEADER: 'specialFateStoreHeaderId'//值1：值2
    //...这里省略了15行
}
//获取值的值 
function getValueName(type) {
    return valueMap[type] ? valueMap[type] : valueMap['SPECIAL_FATE_STORE_HEADER'];
}
//获取键的值
function getKeyName(targetValue){
    let targetArr =  Object.keys(valueMap).filter((key) =&gt; { return valueMap[key] == targetValue });
    return targetArr.length === 0 ? 'STORE_HEADER' :  targetArr[0].split('FATE_')[1]
}
console.log(getValueName('SPECIAL_FATE_STORE_HEADER'),'valueMap')
console.log(getKeyName('specialFateStoreHeaderId'),'valueMap')
</code></pre>
<p>以后再次来需求，我就在<code>valueMap</code>对象里面加。万一再来需求，后台小子还要值3，值4怎么办？难不到我。我修改<code>valueMap</code>的结构。再改下逻辑就行。他还要值5的话，那就叼人或者离职吧。</p>
<pre><code class="language-javascript">let valueMap = {
    SPECIAL_FATE_STORE_HEADER: 'specialFateStoreHeaderId&amp;&amp;值3&amp;&amp;值4'//值1：值2 &amp;&amp; 值3 &amp;&amp; 值4
    //...这里省略了15行
}
</code></pre>
<p><img src="https://upload-images.jianshu.io/upload_images/8195910-d796737ab048781b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="javascript.jpg"></p>
<p>最后，欢迎关注我的公众号。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8195910-4759b64c8d6d9ed7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号二维码.jpg"></p>

</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2020-04-19 10:13</span>&nbsp;
<a href="https://www.cnblogs.com/StephenWu5/">stephenWu5</a>&nbsp;
阅读(<span id="post_view_count">...</span>)&nbsp;
评论(<span id="post_comment_count">...</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=12730384" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(12730384);return false;">收藏</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>
<script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 470246, cb_blogApp = 'StephenWu5', cb_blogUserGuid = '12a8af12-516f-e611-9fc1-ac853d9f53cc';
    var cb_entryId = 12730384, cb_entryCreatedDate = '2020-04-19 10:13', cb_postType = 1; 
    loadViewCount(cb_entryId);
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;"></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;">
            <script>
                if (new Date() >= new Date(2018, 9, 13)) {
                    googletag.cmd.push(function () { googletag.display("div-gpt-ad-1539008685004-0"); });
                }
            </script>
        </div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>
	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>

			<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2020 stephenWu5
<br /><span id="poweredby">Powered by .NET Core on Kubernetes</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    
</body>
</html>