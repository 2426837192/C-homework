<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="never" />
    <meta property="og:description" content="前言 相信大家日常开发中，经常看到Java对象“implements Serializable”。那么，它到底有什么用呢？本文从以下几个角度来解析序列这一块知识点~ 什么是Java序列化？ 为什么需要" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Java程序员必备：序列化全方位解析 - Jay_huaxiao - 博客园</title>
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=BKtyzabbeYJEVOaELkxmRjHbp7LT-v37GzrU5S24bJk" />
    <link id="MainCss" rel="stylesheet" href="/skins/anothereon001/bundle-anothereon001.min.css?v=vmUk-3Bh8LDsKXwjNHs2GDiFna-ZMTUgOJzjUaXTlPA" />
    <link type="text/css" rel="stylesheet" href="https://www.cnblogs.com/jay-huaxiao/custom.css?v=UmSBlgkbjb6mfAIPQ1WdIvlFKR8=" />
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/anothereon001/bundle-anothereon001-mobile.min.css?v=cJiDsI1JAuHHd-OAUWJeyE5JMXXsG4mmuUi2rVmEK1c" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/jay-huaxiao/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/jay-huaxiao/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/jay-huaxiao/wlwmanifest.xml" />
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=VSP5rTXbJNpNidklGdgoLgwCGyUPITrcsmlgoaMKz3w"></script>
    <script>
        var currentBlogId = 449831;
        var currentBlogApp = 'jay-huaxiao';
        var cb_enable_mathjax = false;
        var isLogined = false;
        var skinName = 'AnotherEon001';
    </script>
    
    
    
</head>
<body>
    <a name="top"></a>
    
    <div id="wrapper">
<div id="header">

<div id="top">
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/jay-huaxiao/">huaxiao</a>
</h1>
<div id="subtitle">

</div>
</div>
<div id="sub"><div class="BlogStats">随笔 - 
19, 文章 - 
0, 评论 - 
38, 引用 - 
0</div>

</div>




</div>
<div id="main_container">
<div id="main_content">
<div id="content">
	<div id="post_detail">
    <div class="post">
        <h2>
            
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/jay-huaxiao/p/12730437.html">Java程序员必备：序列化全方位解析</a>

        </h2>
        <div class="postbody">
            
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
    <h3 id="前言">前言</h3>
<p>相信大家日常开发中，经常看到Java对象“implements Serializable”。那么，它到底有什么用呢？本文从以下几个角度来解析序列这一块知识点~</p>
<ul>
<li>什么是Java序列化？</li>
<li>为什么需要序列化？</li>
<li>序列化用途</li>
<li>Java序列化常用API</li>
<li>序列化的使用</li>
<li>序列化底层</li>
<li>日常开发序列化的注意点</li>
<li>序列化常见面试题</li>
</ul>
<h3 id="一、什么是java序列化？">一、什么是Java序列化？</h3>
<ul>
<li>序列化：把Java对象转换为字节序列的过程</li>
<li>反序列：把字节序列恢复为Java对象的过程<br>
<img src="https://user-gold-cdn.xitu.io/2020/4/16/1718072401688be6?w=1618&amp;h=615&amp;f=png&amp;s=97837" alt=""></li>
</ul>
<h3 id="二、为什么需要序列化？">二、为什么需要序列化？</h3>
<p>Java对象是运行在JVM的堆内存中的，如果JVM停止后，它的生命也就戛然而止。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/18/17188de5182865ab?w=1322&amp;h=802&amp;f=png&amp;s=94894" alt=""><br>
如果想在JVM停止后，把这些对象保存到磁盘或者通过网络传输到另一远程机器，怎么办呢？磁盘这些硬件可不认识Java对象，它们只认识二进制这些机器语言，所以我们就要把这些对象转化为字节数组，这个过程就是序列化啦~</p>
<blockquote>
<p>打个比喻，作为大城市漂泊的码农，搬家是常态。当我们搬书桌时，桌子太大了就通不过比较小的门，因此我们需要把它拆开再搬过去，这个拆桌子的过程就是序列化。 而我们把书桌复原回来（安装）的过程就是反序列化啦。</p>
</blockquote>
<h3 id="三、序列化用途">三、序列化用途</h3>
<p>序列化使得对象可以脱离程序运行而独立存在，它主要有两种用途：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/19/17190104b236e38c?w=886&amp;h=444&amp;f=png&amp;s=33182" alt=""></p>
<ul>
<li>1） 序列化机制可以让对象地保存到硬盘上，减轻内存压力的同时，也起了持久化的作用；</li>
</ul>
<blockquote>
<p>比如 Web服务器中的Session对象，当有 10+万用户并发访问的，就有可能出现10万个Session对象，内存可能消化不良，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。</p>
</blockquote>
<ul>
<li>2） 序列化机制让Java对象在网络传输不再是天方夜谭。</li>
</ul>
<blockquote>
<p>我们在使用Dubbo远程调用服务框架时，需要把传输的Java对象实现Serializable接口，即让Java对象序列化，因为这样才能让对象在网络上传输。</p>
</blockquote>
<h3 id="四、java序列化常用api">四、Java序列化常用API</h3>
<pre><code>java.io.ObjectOutputStream
java.io.ObjectInputStream
java.io.Serializable
java.io.Externalizable
</code></pre>
<h4 id="serializable-接口">Serializable 接口</h4>
<p>Serializable接口是一个标记接口，没有方法或字段。一旦实现了此接口，就标志该类的对象就是可序列化的。</p>
<pre><code>public interface Serializable {
}
</code></pre>
<h4 id="externalizable-接口">Externalizable 接口</h4>
<p>Externalizable继承了Serializable接口，还定义了两个抽象方法：writeExternal()和readExternal()，如果开发人员使用Externalizable来实现序列化和反序列化，需要重写writeExternal()和readExternal()方法</p>
<pre><code>public interface Externalizable extends java.io.Serializable {
    void writeExternal(ObjectOutput out) throws IOException;
    void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;
}
</code></pre>
<h4 id="javaioobjectoutputstream类">java.io.ObjectOutputStream类</h4>
<p>表示对象输出流，它的writeObject(Object obj)方法可以对指定obj对象参数进行序列化，再把得到的字节序列写到一个目标输出流中。</p>
<h4 id="javaioobjectinputstream">java.io.ObjectInputStream</h4>
<p>表示对象输入流，<br>
它的readObject()方法，从输入流中读取到字节序列，反序列化成为一个对象，最后将其返回。</p>
<h3 id="五、序列化的使用">五、序列化的使用</h3>
<p>序列化如何使用？来看一下，序列化的使用的几个关键点吧：</p>
<ul>
<li>声明一个实体类，实现Serializable接口</li>
<li>使用ObjectOutputStream类的writeObject方法，实现序列化</li>
<li>使用ObjectInputStream类的readObject方法，实现反序列化</li>
</ul>
<h4 id="声明一个student类，实现serializable">声明一个Student类，实现Serializable</h4>
<pre><code>public class Student implements Serializable {

    private Integer age;
    private String name;

    public Integer getAge() {
        return age;
    }
    public void setAge(Integer age) {
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
</code></pre>
<h4 id="使用objectoutputstream类的writeobject方法，对student对象实现序列化">使用ObjectOutputStream类的writeObject方法，对Student对象实现序列化</h4>
<p>把Student对象设置值后，写入一个文件，即序列化，哈哈~</p>
<pre><code>ObjectOutputStream objectOutputStream = new ObjectOutputStream( new FileOutputStream(&quot;D:\\text.out&quot;));
Student student = new Student();
student.setAge(25);
student.setName(&quot;jayWei&quot;);
objectOutputStream.writeObject(student);

objectOutputStream.flush();
objectOutputStream.close();
</code></pre>
<p>看看序列化的可爱模样吧，test.out文件内容如下（使用UltraEdit打开）：<br>
<img src="https://user-gold-cdn.xitu.io/2020/4/18/1718cb65a1d08785?w=896&amp;h=311&amp;f=png&amp;s=59011" alt=""></p>
<h4 id="使用objectinputstream类的readobject方法，实现反序列化，重新生成student对象">使用ObjectInputStream类的readObject方法，实现反序列化，重新生成student对象</h4>
<p>再把test.out文件读取出来，反序列化为Student对象</p>
<pre><code>ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;D:\\text.out&quot;));
Student student = (Student) objectInputStream.readObject();
System.out.println(&quot;name=&quot;+student.getName());
</code></pre>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/18/1718cb9ec7ca958f?w=1227&amp;h=395&amp;f=png&amp;s=46746" alt=""></p>
<h3 id="六、序列化底层">六、序列化底层</h3>
<h4 id="serializable底层">Serializable底层</h4>
<p>Serializable接口，只是一个空的接口，没有方法或字段，为什么这么神奇，实现了它就可以让对象序列化了？</p>
<pre><code>public interface Serializable {
}
</code></pre>
<p>为了验证Serializable的作用，把以上demo的Student对象，去掉实现Serializable接口，看序列化过程怎样吧~</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/18/1718cbbb01a02999?w=607&amp;h=542&amp;f=png&amp;s=46516" alt=""></p>
<p>序列化过程中抛出异常啦，堆栈信息如下：</p>
<pre><code>Exception in thread &quot;main&quot; java.io.NotSerializableException: com.example.demo.Student
	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184)
	at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)
	at com.example.demo.Test.main(Test.java:13)
</code></pre>
<p>顺着堆栈信息看一下，原来有重大发现，如下~<br>
<img src="https://user-gold-cdn.xitu.io/2020/4/18/1718c980c904c2ee?w=802&amp;h=636&amp;f=png&amp;s=69506" alt=""><br>
<strong>原来底层是这样：</strong><br>
ObjectOutputStream 在序列化的时候，会判断被序列化的Object是哪一种类型，String？array？enum？还是 Serializable，如果都不是的话，抛出 NotSerializableException异常。所以呀，<strong>Serializable真的只是一个标志，一个序列化标志</strong>~</p>
<h4 id="writeobject（object）">writeObject（Object）</h4>
<p>序列化的方法就是writeObject，基于以上的demo，我们来分析一波它的核心方法调用链吧~（建议大家也去debug看一下这个方法，感兴趣的话）<br>
<img src="https://user-gold-cdn.xitu.io/2020/4/18/1718d1fbad278f8f?w=668&amp;h=1003&amp;f=png&amp;s=60938" alt=""></p>
<p>writeObject直接调用的就是writeObject0（）方法，</p>
<pre><code>public final void writeObject(Object obj) throws IOException {
    ......
    writeObject0(obj, false);
    ......
}
</code></pre>
<p>writeObject0 主要实现是对象的不同类型，调用不同的方法写入序列化数据，这里面如果对象实现了Serializable接口，就调用writeOrdinaryObject()方法~</p>
<pre><code>private void writeObject0(Object obj, boolean unshared)
        throws IOException
    {
    ......
   //String类型
    if (obj instanceof String) {
        writeString((String) obj, unshared);
   //数组类型
    } else if (cl.isArray()) {
        writeArray(obj, desc, unshared);
   //枚举类型
    } else if (obj instanceof Enum) {
        writeEnum((Enum&lt;?&gt;) obj, desc, unshared);
   //Serializable实现序列化接口
    } else if (obj instanceof Serializable) {
        writeOrdinaryObject(obj, desc, unshared);
    } else{
        //其他情况会抛异常~
        if (extendedDebugInfo) {
            throw new NotSerializableException(
                cl.getName() + &quot;\n&quot; + debugInfoStack.toString());
        } else {
            throw new NotSerializableException(cl.getName());
        }
    }
    ......
</code></pre>
<p>writeOrdinaryObject()会先调用writeClassDesc(desc)，写入该类的生成信息，然后调用writeSerialData方法,写入序列化数据</p>
<pre><code>    private void writeOrdinaryObject(Object obj,
                                     ObjectStreamClass desc,
                                     boolean unshared)
        throws IOException
    {
            ......
            //调用ObjectStreamClass的写入方法
            writeClassDesc(desc, false);
            // 判断是否实现了Externalizable接口
            if (desc.isExternalizable() &amp;&amp; !desc.isProxy()) {
                writeExternalData((Externalizable) obj);
            } else {
                //写入序列化数据
                writeSerialData(obj, desc);
            }
            .....
    }
</code></pre>
<p>writeSerialData（）实现的就是写入被序列化对象的字段数据</p>
<pre><code>  private void writeSerialData(Object obj, ObjectStreamClass desc)
        throws IOException
    {
        for (int i = 0; i &lt; slots.length; i++) {
            if (slotDesc.hasWriteObjectMethod()) {
                   //如果被序列化的对象自定义实现了writeObject()方法，则执行这个代码块
                    slotDesc.invokeWriteObject(obj, this);
            } else {
                // 调用默认的方法写入实例数据
                defaultWriteFields(obj, slotDesc);
            }
        }
    }
</code></pre>
<p>defaultWriteFields（）方法，获取类的基本数据类型数据，直接写入底层字节容器；获取类的obj类型数据，循环递归调用writeObject0()方法，写入数据~</p>
<pre><code>   private void defaultWriteFields(Object obj, ObjectStreamClass desc)
        throws IOException
    {   
        // 获取类的基本数据类型数据，保存到primVals字节数组
        desc.getPrimFieldValues(obj, primVals);
        //primVals的基本类型数据写到底层字节容器
        bout.write(primVals, 0, primDataSize, false);

        // 获取对应类的所有字段对象
        ObjectStreamField[] fields = desc.getFields(false);
        Object[] objVals = new Object[desc.getNumObjFields()];
        int numPrimFields = fields.length - objVals.length;
        // 获取类的obj类型数据，保存到objVals字节数组
        desc.getObjFieldValues(obj, objVals);
        //对所有Object类型的字段,循环
        for (int i = 0; i &lt; objVals.length; i++) {
            ......
              //递归调用writeObject0()方法，写入对应的数据
            writeObject0(objVals[i],
                             fields[numPrimFields + i].isUnshared());
            ......
        }
    }
</code></pre>
<h3 id="七、日常开发序列化的一些注意点">七、日常开发序列化的一些注意点</h3>
<ul>
<li>static静态变量和transient 修饰的字段是不会被序列化的</li>
<li>serialVersionUID问题</li>
<li>如果某个序列化类的成员变量是对象类型，则该对象类型的类必须实现序列化</li>
<li>子类实现了序列化，父类没有实现序列化，父类中的字段丢失问题</li>
</ul>
<h4 id="static静态变量和transient-修饰的字段是不会被序列化的">static静态变量和transient 修饰的字段是不会被序列化的</h4>
<p>static静态变量和transient 修饰的字段是不会被序列化的,我们来看例子分析一波~ Student类加了一个类变量gender和一个transient修饰的字段specialty</p>
<pre><code>public class Student implements Serializable {

    private Integer age;
    private String name;

    public static String gender = &quot;男&quot;;
    transient  String specialty = &quot;计算机专业&quot;;

    public String getSpecialty() {
        return specialty;
    }

    public void setSpecialty(String specialty) {
        this.specialty = specialty;
    }

    @Override
    public String toString() {
        return &quot;Student{&quot; +&quot;age=&quot; + age + &quot;, name='&quot; + name + '\'' + &quot;, gender='&quot; + gender + '\'' + &quot;, specialty='&quot; + specialty + '\'' +
                '}';
    }
    ......
</code></pre>
<p>打印学生对象，序列化到文件，接着修改静态变量的值，再反序列化，输出反序列化后的对象~<br>
<img src="https://user-gold-cdn.xitu.io/2020/4/19/1718e0bcd6cdcbfe?w=1240&amp;h=527&amp;f=png&amp;s=83206" alt=""><br>
运行结果：</p>
<pre><code>序列化前Student{age=25, name='jayWei', gender='男', specialty='计算机专业'}
序列化后Student{age=25, name='jayWei', gender='女', specialty='null'}
</code></pre>
<p>对比结果可以发现：</p>
<ul>
<li>1）序列化前的静态变量性别明明是‘男’，序列化后再在程序中修改，反序列化后却变成‘女’了，<strong>what</strong>？显然这个静态属性并没有进行序列化。其实，<strong>静态（static）成员变量是属于类级别的，而序列化是针对对象的~所以不能序列化哦</strong>。</li>
<li>2）经过序列化和反序列化过程后，specialty字段变量值由'计算机专业'变为空了，为什么呢？其实是因为transient关键字，<strong>它可以阻止修饰的字段被序列化到文件中</strong>，在被反序列化后，transient 字段的值被设为初始值，比如int型的值会被设置为 0，对象型初始值会被设置为null。</li>
</ul>
<h4 id="serialversionuid问题">serialVersionUID问题</h4>
<p>serialVersionUID 表面意思就是<strong>序列化版本号ID</strong>，其实每一个实现Serializable接口的类，都有一个表示序列化版本标识符的静态变量，或者默认等于1L，或者等于对象的哈希码。</p>
<pre><code>private static final long serialVersionUID = -6384871967268653799L;
</code></pre>
<p><strong>serialVersionUID有什么用？</strong></p>
<p>JAVA序列化的机制是通过判断类的serialVersionUID来验证版本是否一致的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID和本地相应实体类的serialVersionUID进行比较，如果相同，反序列化成功，如果不相同，就抛出InvalidClassException异常。</p>
<p>接下来，我们来验证一下吧，修改一下Student类，再反序列化操作</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/19/1718f8eb4c01274f?w=593&amp;h=315&amp;f=png&amp;s=29002" alt=""></p>
<pre><code>Exception in thread &quot;main&quot; java.io.InvalidClassException: com.example.demo.Student;
local class incompatible: stream classdesc serialVersionUID = 3096644667492403394,
local class serialVersionUID = 4429793331949928814
	at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:687)
	at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1876)
	at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1745)
	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2033)
	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1567)
	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:427)
	at com.example.demo.Test.main(Test.java:20)
</code></pre>
<p>从日志堆栈异常信息可以看到，文件流中的class和当前类路径中的class不同了，它们的serialVersionUID不相同，所以反序列化抛出InvalidClassException异常。那么，如果确实需要修改Student类，又想反序列化成功，怎么办呢？可以手动指定serialVersionUID的值，一般可以设置为1L或者，或者让我们的编辑器IDE生成</p>
<pre><code>private static final long serialVersionUID = -6564022808907262054L;
</code></pre>
<p>实际上，阿里开发手册，强制要求序列化类新增属性时，不能修改serialVersionUID字段~<br>
<img src="https://user-gold-cdn.xitu.io/2020/4/19/1718f78ab09a17cd?w=925&amp;h=140&amp;f=png&amp;s=39827" alt=""></p>
<h4 id="如果某个序列化类的成员变量是对象类型，则该对象类型的类必须实现序列化">如果某个序列化类的成员变量是对象类型，则该对象类型的类必须实现序列化</h4>
<p>给Student类添加一个Teacher类型的成员变量，其中Teacher是没有实现序列化接口的</p>
<pre><code>public class Student implements Serializable {
    
    private Integer age;
    private String name;
    private Teacher teacher;
    ...
}
//Teacher 没有实现
public class Teacher  {
......
}
</code></pre>
<p>序列化运行，就报NotSerializableException异常啦</p>
<pre><code>Exception in thread &quot;main&quot; java.io.NotSerializableException: com.example.demo.Teacher
	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184)
	at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1548)
	at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1509)
	at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1432)
	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1178)
	at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)
	at com.example.demo.Test.main(Test.java:16)
</code></pre>
<p>其实这个可以在上小节的底层源码分析找到答案，一个对象序列化过程，会循环调用它的Object类型字段，递归调用序列化的，也就是说，序列化Student类的时候，会对Teacher类进行序列化，但是对Teacher没有实现序列化接口，因此抛出NotSerializableException异常。所以如果某个实例化类的成员变量是对象类型，则该对象类型的类必须实现序列化<br>
<img src="https://user-gold-cdn.xitu.io/2020/4/19/1718fa928a6ff178?w=852&amp;h=415&amp;f=png&amp;s=52155" alt=""></p>
<h4 id="子类实现了serializable，父类没有实现serializable接口的话，父类不会被序列化。">子类实现了Serializable，父类没有实现Serializable接口的话，父类不会被序列化。</h4>
<p>子类Student实现了Serializable接口，父类User没有实现Serializable接口</p>
<pre><code>//父类实现了Serializable接口
public class Student  extends User implements Serializable {

    private Integer age;
    private String name;
}
//父类没有实现Serializable接口
public class User {
    String userId;
}

Student student = new Student();
student.setAge(25);
student.setName(&quot;jayWei&quot;);
student.setUserId(&quot;1&quot;);

ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;D:\\text.out&quot;));
objectOutputStream.writeObject(student);

objectOutputStream.flush();
objectOutputStream.close();

//反序列化结果
ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;D:\\text.out&quot;));
Student student1 = (Student) objectInputStream.readObject();
System.out.println(student1.getUserId());
//output
/** 
 * null
 */
</code></pre>
<p>从反序列化结果，可以发现，父类属性值丢失了。因此子类实现了Serializable接口，父类没有实现Serializable接口的话，父类不会被序列化。</p>
<h3 id="八、序列化常见面试题">八、序列化常见面试题</h3>
<ul>
<li>序列化的底层是怎么实现的？</li>
<li>序列化时，如何让某些成员不要序列化？</li>
<li>在 Java 中,Serializable 和 Externalizable 有什么区别</li>
<li>serialVersionUID有什么用？</li>
<li>是否可以自定义序列化过程, 或者是否可以覆盖 Java 中的默认序列化过程？</li>
<li>在 Java 序列化期间,哪些变量未序列化？</li>
</ul>
<h4 id="1序列化的底层是怎么实现的？">1.序列化的底层是怎么实现的？</h4>
<p>本文第六小节可以回答这个问题，如回答Serializable关键字作用，序列化标志啦，源码中，它的作用啦<sub>还有，可以回答writeObject几个核心方法，如直接写入基本类型，获取obj类型数据，循环递归写入，哈哈</sub></p>
<h4 id="2序列化时，如何让某些成员不要序列化？">2.序列化时，如何让某些成员不要序列化？</h4>
<p>可以用transient关键字修饰，它可以阻止修饰的字段被序列化到文件中，在被反序列化后，transient 字段的值被设为初始值，比如int型的值会被设置为 0，对象型初始值会被设置为null。</p>
<h4 id="3在-java-中serializable-和-externalizable-有什么区别">3.在 Java 中,Serializable 和 Externalizable 有什么区别</h4>
<p>Externalizable继承了Serializable，给我们提供 writeExternal() 和 readExternal() 方法, 让我们可以控制 Java的序列化机制, 不依赖于Java的默认序列化。正确实现 Externalizable 接口可以显著提高应用程序的性能。</p>
<h4 id="4serialversionuid有什么用？">4.serialVersionUID有什么用？</h4>
<p>可以看回本文第七小节哈，JAVA序列化的机制是通过判断类的serialVersionUID来验证版本是否一致的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID和本地相应实体类的serialVersionUID进行比较，如果相同，反序列化成功，如果不相同，就抛出InvalidClassException异常。</p>
<h4 id="5是否可以自定义序列化过程-或者是否可以覆盖-java-中的默认序列化过程？">5.是否可以自定义序列化过程, 或者是否可以覆盖 Java 中的默认序列化过程？</h4>
<p>可以的。我们都知道,对于序列化一个对象需调用 ObjectOutputStream.writeObject(saveThisObject), 并用 ObjectInputStream.readObject() 读取对象, 但 Java 虚拟机为你提供的还有一件事, 是定义这两个方法。如果在类中定义这两种方法, 则 JVM 将调用这两种方法, 而不是应用默认序列化机制。同时，可以声明这些方法为私有方法，以避免被继承、重写或重载。</p>
<h4 id="6在-java-序列化期间哪些变量未序列化？">6.在 Java 序列化期间,哪些变量未序列化？</h4>
<p>static静态变量和transient 修饰的字段是不会被序列化的。静态（static）成员变量是属于类级别的，而序列化是针对对象的。transient关键字修字段饰，可以阻止该字段被序列化到文件中。</p>
<h3 id="参考与感谢">参考与感谢</h3>
<ul>
<li><a href="https://www.cnblogs.com/xdp-gacl/p/3777987.html">Java基础学习总结——Java对象的序列化和反序列化</a></li>
<li><a href="https://segmentfault.com/a/1190000019962661">10个艰难的Java面试题与答案</a></li>
</ul>
<h3 id="个人公众号">个人公众号</h3>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/28/16c381c89b127bbb?w=344&amp;h=344&amp;f=jpeg&amp;s=8943" alt=""></p>
<ul>
<li>觉得写得好的小伙伴给个点赞+关注啦，谢谢~</li>
<li>如果有写得不正确的地方，麻烦指出，感激不尽。</li>
<li>同时非常期待小伙伴们能够关注我公众号，后面慢慢推出更好的干货~嘻嘻</li>
</ul>

</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
        </div>
        <p class="postfoot">
            posted on 
<span id="post-date">2020-04-19 10:29</span>&nbsp;
<a href="https://www.cnblogs.com/jay-huaxiao/">Jay_huaxiao</a>&nbsp;
阅读(<span id="post_view_count">...</span>)&nbsp;
评论(<span id="post_comment_count">...</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=12730437" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(12730437);return false;">收藏</a>
        </p>
    </div>
</div>

<script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 449831, cb_blogApp = 'jay-huaxiao', cb_blogUserGuid = '932b17be-b8a5-48ea-318e-08d5f84d9736';
    var cb_entryId = 12730437, cb_entryCreatedDate = '2020-04-19 10:29', cb_postType = 1; 
    loadViewCount(cb_entryId);
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;"></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;">
            <script>
                if (new Date() >= new Date(2018, 9, 13)) {
                    googletag.cmd.push(function () { googletag.display("div-gpt-ad-1539008685004-0"); });
                }
            </script>
        </div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>

</div>
</div>
<div id="leftmenu">


<h3>导航</h3>
<ul>
    <li>
        <a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>

    </li>
    <li>
        
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/jay-huaxiao/">
首页</a>

    </li>
    <li>
        

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>

    </li>
    <li>
        
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/Jay_huaxiao">
联系</a>
    </li>
    <li>
        
<a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/jay-huaxiao/rss/">
订阅</a>
        
<a id="blog_nav_rss_image" href="https://www.cnblogs.com/jay-huaxiao/rss/">
    <img src="/skins/anothereon001/images/xml.gif" alt="订阅" />
</a>
    </li>
    <li>
        
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>

    </li>
</ul>


<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>

<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>

<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>

</div>
</div>
<div class="clear"></div>
<div id="footer">
<p id="footer">
	Powered by: 
	<br />
	
	
<a href="https://www.cnblogs.com/" id="Footer1_Hyperlink3" style="font-size: 12px; font-family: Verdana">博客园</a>
	<br />
	Copyright &copy; 2020 Jay_huaxiao
<br /><span id="poweredby">Powered by .NET Core on Kubernetes</span>

</p>


</div>
</div>


    
</body>
</html>